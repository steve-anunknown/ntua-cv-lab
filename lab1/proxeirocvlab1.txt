
        #ix, iy = image.shape
        #result = np.zeros((n + ix - 1, n + iy - 1))
        #padded = np.pad(image, [(n//2, n//2), (n//2, n//2)], mode='constant')
        #for i in range(n//2, ix + n//2):
        #    for j in range(n//2, iy + n//2):
        #        result[i,j] = np.sum(padded[i-n//2:i+n//2+1, j-n//2:j+n//2+1] * kernel)
        #return result[n//2:ix+n//2, n//2:iy+n//2]

        #logkernel = np.zeros((3 + n//2 - 1, 3 + n//2 - 1))
        #padded = np.pad(kernel, [(3//2,3//2),(3//2,3//2)], mode='constant')
        #for i in range(3//2, n + 3//2):
        #    for j in range(3//2, n + 3//2):
        #        logkernel[i,j] = np.sum(padded[i - 3//2:i+3//2+1, j-3//2:j+3//2+1 ] * laplacian)

        kx = cv2.getGaussianKernel(n, sigma)
        ky = cv2.getGaussianKernel(n, sigma)
        kernel = np.multiply(kx, np.transpose(ky))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 

        #ix, iy = image.shape
        #n = logkernel.shape[0]
        #result = np.zeros((n + ix - 1, n + iy - 1))
        #padded = np.pad(image, [(n//2, n//2), (n//2, n//2)], mode='constant')
        #for i in range(n//2, ix + n//2):
        #    for j in range(n//2, iy + n//2):
        #        result[i,j] = np.sum(padded[i-n//2:i+n//2+1, j-n//2:j+n//2+1] * kernel)
        #return result[n//2:ix+n//2, n//2:iy+n//2]
def myfilter(image, sigma, method):
    if (method == "gaussian"):
        n = int(np.ceil(3*sigma)*2 + 1)
        # generating the kernels using meshgrid is
        # said to be more accurate than multiplying
        # two 1d gaussian kernels together. That is
        # because the product of two gaussian functions
        # is not neccessarily a gaussian function, so
        # there may be a loss of symmetry between the
        # x, y axis.
        x, y = np.meshgrid(np.arange(-n//2+1, n//2+1),
                           np.arange(-n//2+1, n//2+1))
        kernel = np.exp(-(x**2+y**2)/(2*sigma**2))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 
        result = my2dconv(image, kernel)
        return result
    if (method == "log"):
        n = int(np.ceil(3*sigma)*2 + 1)
        x, y = np.meshgrid(np.arange(-n//2+1, n//2+1),
                           np.arange(-n//2+1, n//2+1))
        kernel = np.exp(-(x**2+y**2)/(2*sigma**2))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 
        laplacian = np.array([[0,1,0],
                              [1,-4,1],
                              [0,1,0]])
        # perform the convolution between the gaussian kernel
        # and the laplacian, in order to create the log kernel
        logkernel = my2dconv(kernel, laplacian)
        result = my2dconv(image, logkernel)
        return result
    print("Error: method has to be either \"gaussian\" or \"log\"")

for index, nsd_img in enumerate(noised_images):
    # plot the images
    fig, axs = plt.subplots(1, 2)
    axs[0].imshow(image, cmap='gray')
    axs[1].imshow(nsd_img, cmap='gray')
    axs[0].set_title("Original Image")
    axs[1].set_title("Image with gaussian noise")
    plt.show()

    # It can be seen that, indeed, the 10db PSNR gaussian noise
    # is more intense than the 20db PSNR one.

    # laplacian on gaussian
    logfilter1 = myfilter(sigma[index], "log")
    img_loged1 = cv2.filter2D(nsd_img, -1, logfilter1)

    # non linear approximation of laplacian on gaussian
    # using morphological operators
    gaussianfilter = myfilter(sigma[index], "gaussian")
    img_gaussed = cv2.filter2D(nsd_img, -1, gaussianfilter)

    cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
    img_loged2 = cv2.dilate(img_gaussed, cross) + cv2.erode(img_gaussed, cross) - 2*img_gaussed

    fig, axs = plt.subplots(1, 3)
    axs[0].imshow(img_gaussed, cmap='gray')
    axs[0].set_title("Gaussianly Smoothed Image")
    axs[1].imshow(img_loged1, cmap='gray')
    axs[1].set_title("LoGed Image (Linear Approximation)")
    axs[2].imshow(img_loged2, cmap='gray')
    axs[2].set_title("LoGed Image (Non Linear Approximation)")
    plt.show()

    # at this point, it can be seen that the non linear approximation
    # is better, and from now on this one is going to be used.

    L = img_loged2
    X = (L >= 0).astype(np.uint8)
    # Y is approximately the edges of image L
    Y = (cv2.dilate(X, cross)) - (cv2.erode(X, cross))
    gradx, grady = np.gradient(img_gaussed)
    grad = np.abs(gradx + 1j * grady)
    D = (Y == 1 & (grad > theta[index] * np.max(grad)))
    fig, axs = plt.subplots(1,2)
    axs[0].imshow(Y, cmap='gray')
    axs[0].set_title("The edges of the image")
    axs[1].imshow(D, cmap='gray')
    axs[1].set_title("The actual edges of the image")
    plt.show()
