
        #ix, iy = image.shape
        #result = np.zeros((n + ix - 1, n + iy - 1))
        #padded = np.pad(image, [(n//2, n//2), (n//2, n//2)], mode='constant')
        #for i in range(n//2, ix + n//2):
        #    for j in range(n//2, iy + n//2):
        #        result[i,j] = np.sum(padded[i-n//2:i+n//2+1, j-n//2:j+n//2+1] * kernel)
        #return result[n//2:ix+n//2, n//2:iy+n//2]

        #logkernel = np.zeros((3 + n//2 - 1, 3 + n//2 - 1))
        #padded = np.pad(kernel, [(3//2,3//2),(3//2,3//2)], mode='constant')
        #for i in range(3//2, n + 3//2):
        #    for j in range(3//2, n + 3//2):
        #        logkernel[i,j] = np.sum(padded[i - 3//2:i+3//2+1, j-3//2:j+3//2+1 ] * laplacian)

        kx = cv2.getGaussianKernel(n, sigma)
        ky = cv2.getGaussianKernel(n, sigma)
        kernel = np.multiply(kx, np.transpose(ky))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 

        #ix, iy = image.shape
        #n = logkernel.shape[0]
        #result = np.zeros((n + ix - 1, n + iy - 1))
        #padded = np.pad(image, [(n//2, n//2), (n//2, n//2)], mode='constant')
        #for i in range(n//2, ix + n//2):
        #    for j in range(n//2, iy + n//2):
        #        result[i,j] = np.sum(padded[i-n//2:i+n//2+1, j-n//2:j+n//2+1] * kernel)
        #return result[n//2:ix+n//2, n//2:iy+n//2]
def myfilter(image, sigma, method):
    if (method == "gaussian"):
        n = int(np.ceil(3*sigma)*2 + 1)
        # generating the kernels using meshgrid is
        # said to be more accurate than multiplying
        # two 1d gaussian kernels together. That is
        # because the product of two gaussian functions
        # is not neccessarily a gaussian function, so
        # there may be a loss of symmetry between the
        # x, y axis.
        x, y = np.meshgrid(np.arange(-n//2+1, n//2+1),
                           np.arange(-n//2+1, n//2+1))
        kernel = np.exp(-(x**2+y**2)/(2*sigma**2))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 
        result = my2dconv(image, kernel)
        return result
    if (method == "log"):
        n = int(np.ceil(3*sigma)*2 + 1)
        x, y = np.meshgrid(np.arange(-n//2+1, n//2+1),
                           np.arange(-n//2+1, n//2+1))
        kernel = np.exp(-(x**2+y**2)/(2*sigma**2))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 
        laplacian = np.array([[0,1,0],
                              [1,-4,1],
                              [0,1,0]])
        # perform the convolution between the gaussian kernel
        # and the laplacian, in order to create the log kernel
        logkernel = my2dconv(kernel, laplacian)
        result = my2dconv(image, logkernel)
        return result
    print("Error: method has to be either \"gaussian\" or \"log\"")

for index, nsd_img in enumerate(noised_images):
    # plot the images
    fig, axs = plt.subplots(1, 2)
    axs[0].imshow(image, cmap='gray')
    axs[1].imshow(nsd_img, cmap='gray')
    axs[0].set_title("Original Image")
    axs[1].set_title("Image with gaussian noise")
    plt.show()

    # It can be seen that, indeed, the 10db PSNR gaussian noise
    # is more intense than the 20db PSNR one.

    # laplacian on gaussian
    logfilter1 = myfilter(sigma[index], "log")
    img_loged1 = cv2.filter2D(nsd_img, -1, logfilter1)

    # non linear approximation of laplacian on gaussian
    # using morphological operators
    gaussianfilter = myfilter(sigma[index], "gaussian")
    img_gaussed = cv2.filter2D(nsd_img, -1, gaussianfilter)

    cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
    img_loged2 = cv2.dilate(img_gaussed, cross) + cv2.erode(img_gaussed, cross) - 2*img_gaussed

    fig, axs = plt.subplots(1, 3)
    axs[0].imshow(img_gaussed, cmap='gray')
    axs[0].set_title("Gaussianly Smoothed Image")
    axs[1].imshow(img_loged1, cmap='gray')
    axs[1].set_title("LoGed Image (Linear Approximation)")
    axs[2].imshow(img_loged2, cmap='gray')
    axs[2].set_title("LoGed Image (Non Linear Approximation)")
    plt.show()

    # at this point, it can be seen that the non linear approximation
    # is better, and from now on this one is going to be used.

    L = img_loged2
    X = (L >= 0).astype(np.uint8)
    # Y is approximately the edges of image L
    Y = (cv2.dilate(X, cross)) - (cv2.erode(X, cross))
    gradx, grady = np.gradient(img_gaussed)
    grad = np.abs(gradx + 1j * grady)
    D = (Y == 1 & (grad > theta[index] * np.max(grad)))
    fig, axs = plt.subplots(1,2)
    axs[0].imshow(Y, cmap='gray')
    axs[0].set_title("The edges of the image")
    axs[1].imshow(D, cmap='gray')
    axs[1].set_title("The actual edges of the image")
    plt.show()



    gradsxx = [img_grad2(image, s)[0] for (s, _) in params]
    gradsyy = [img_grad2(image, s)[2] for (s, _) in params]
    grads = list(zip(scales, gradsxx, gradsyy))
    logs = [(s**2)*np.abs(xx + yy) for (s, xx, yy) in grads]
    # now we iterate through the points and compare each scale
    # with its previous and its next. if the log metric is not
    # maximized, we reject it. 
    final = []
    for index, blobs in enumerate(blobs_per_scale):
        logp = logs[max(index-1,0)]
        logc = logs[index]
        logn = logs[min(index+1,N-1)] 
        for triplet in blobs:
            x = int(triplet[1])
            y = int(triplet[0])
            prev = logp[x][y]
            curr = logc[x][y]
            next = logn[x][y]
            if (curr >= prev) and (curr >= next):
                final.append(triplet)
    return np.array(final)



def IntegralImageManual(i):
    x, y = i.shape
    r = np.zeros(i.shape)
    # r[ix][0] = 0 for all ix
    # r[0][iy] = 0 for all iy
    for ix in list(range(1,x)):
        for iy in list(range(1,y)):
            r[ix][iy] = i[ix][iy] - r[ix-1][iy-1] + r[ix][iy-1] + r[ix-1][iy]
    return r


def BoxFilter(ii, height, width):
    # get the center of the box
    cx, cy = width//2, height//2
    # we have to pad the integral image
    # in order to properly handle the
    # boundary points. the boundaries are
    # zero, therefore the padding values
    # are also zero.

    # the amount of padding is half of whatever edge of the box, therefore
    # cy at the top, cy at the bottom, cx on the left, cx on the right
    padded = np.pad(ii, ((cy, cy), (cx, cx)), mode='constant')

def BoxSOD(image, sigma):
    # box second order derivative
    def roi(im, height, width):
        # roi = Rectangle Of Interest
        # get the center of the box
        cx = (width + 1)/2 - 1
        cy = (height + 1)/2 - 1
        # pad it. this is necessary because the (x,y) pixel of the output
        # refers to the center of the box which we calculate the mean of.
        # therefore, in order to get the same dimensionality as the original image
        # we have to pad it and then unpad it. otherwise, the edges will be missing.

        # pad the image up and down by height
        # pad the image left and right by width
        padded = np.pad(im, ((height, height),(width, width)), mode='edge')
        padded = np.pad(padded, ((height, height),(width, width)), mode='constant')
        a = np.roll(padded, shift=(cy+1, cx+1), axis=(0, 1))
        b = np.roll(padded, shift=(cy+1, -cx), axis=(0, 1))
        c = np.roll(padded, shift=(-cy, -cx), axis=(0, 1))
        d = np.roll(padded, shift=(-cy, cx+1), axis=(0, 1))
        result = a + c - b - d
        # unpad it
        result = result[cy+2:-cy-1, cx+2:-cx-1]

    # get integral image
    ii = IntegralImage(image)

    # define the boxes
    n = 2*np.ceil(3*sigma)+1
    heightxx = 4*np.floor(n/6)+1
    widthxx = 2*np.floor(n/6)+1
    cxxx = (widthxx+1)/2 - 1
    cxxy = (heightxx+1)/2 - 1
    # pad the width to avoid conflicts
    lxx = np.pad(lxx, ((0, 0), (widthxx, widthxx)), mode='constant')
    lxx = roi(ii, heightxx, widthxx)
    lxx = np.roll(lxx, shift=(0, -widthxx), axis=(0,1)) - 2*lxx + np.roll(lxx, shift=(0, widthxx), axis=(0,1))
    # unpad
    lxx = lxx[cxxy+1:-cxxy, widthxx+cxxx+1:-widthxx-cxxx]

    heightxy = 2*np.floor(n/6)+1
    widthxy = 2*np.floor(n/6)+1
    cxyx = (widthxy+1)/2 - 1
    cxyy = (heightxy+1)/2 - 1
    # pad the width to avoid conflicts
    lxy = np.pad(lxy, ((cxyy+1, cxyy+1),(cxyx+1,cxyx+1)), mode='constant')
    lxy = roi(ii, heightxy, widthxy)
    lxy = np.roll(lxy, shift=(-cxyy-1, -cxyx-1), axis=(0,1)) + np.roll(lxy, shift=(cxyy+1, cxyx+1), axis=(0,1)) - np.roll(lxy, shift=(cxyy+1, -cxyx-1), axis=(0,1)) - np.roll(lxy, shift=(-cxyy-1, cxyx+1), axis=(0,1))
    # unpad
    lxy = lxy[2*cxyy+2:-2*cxyy-1, 2*cxyx+2:-2*cxyx-1]

    heightyy = 2*np.floor(n/6)+1
    widthyy = 4*np.floor(n/6)+1
    cyyx = (widthyy+1)/2 - 1
    cyyy = (heightyy+1)/2 - 1
    # pad the width to avoid conflicts
    lyy = np.pad(lyy, ((heightyy, heightyy), (0, 0)), mode='constant')
    lyy = roi(ii, heightyy, widthyy)
    lyy = np.roll(lyy, shift=(0, -widthyy), axis=(0,1)) - 2*lyy + np.roll(lyy, shift=(0, widthyy), axis=(0,1))
    # unpad
    lyy = lyy[heightyy+cyyy+1:-heightyy-cyy, cyyx+1:-cyyx]

    return (lxx, lxy, lyy)