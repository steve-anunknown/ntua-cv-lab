
        #ix, iy = image.shape
        #result = np.zeros((n + ix - 1, n + iy - 1))
        #padded = np.pad(image, [(n//2, n//2), (n//2, n//2)], mode='constant')
        #for i in range(n//2, ix + n//2):
        #    for j in range(n//2, iy + n//2):
        #        result[i,j] = np.sum(padded[i-n//2:i+n//2+1, j-n//2:j+n//2+1] * kernel)
        #return result[n//2:ix+n//2, n//2:iy+n//2]

        #logkernel = np.zeros((3 + n//2 - 1, 3 + n//2 - 1))
        #padded = np.pad(kernel, [(3//2,3//2),(3//2,3//2)], mode='constant')
        #for i in range(3//2, n + 3//2):
        #    for j in range(3//2, n + 3//2):
        #        logkernel[i,j] = np.sum(padded[i - 3//2:i+3//2+1, j-3//2:j+3//2+1 ] * laplacian)

        kx = cv2.getGaussianKernel(n, sigma)
        ky = cv2.getGaussianKernel(n, sigma)
        kernel = np.multiply(kx, np.transpose(ky))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 

        #ix, iy = image.shape
        #n = logkernel.shape[0]
        #result = np.zeros((n + ix - 1, n + iy - 1))
        #padded = np.pad(image, [(n//2, n//2), (n//2, n//2)], mode='constant')
        #for i in range(n//2, ix + n//2):
        #    for j in range(n//2, iy + n//2):
        #        result[i,j] = np.sum(padded[i-n//2:i+n//2+1, j-n//2:j+n//2+1] * kernel)
        #return result[n//2:ix+n//2, n//2:iy+n//2]
def myfilter(image, sigma, method):
    if (method == "gaussian"):
        n = int(np.ceil(3*sigma)*2 + 1)
        # generating the kernels using meshgrid is
        # said to be more accurate than multiplying
        # two 1d gaussian kernels together. That is
        # because the product of two gaussian functions
        # is not neccessarily a gaussian function, so
        # there may be a loss of symmetry between the
        # x, y axis.
        x, y = np.meshgrid(np.arange(-n//2+1, n//2+1),
                           np.arange(-n//2+1, n//2+1))
        kernel = np.exp(-(x**2+y**2)/(2*sigma**2))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 
        result = my2dconv(image, kernel)
        return result
    if (method == "log"):
        n = int(np.ceil(3*sigma)*2 + 1)
        x, y = np.meshgrid(np.arange(-n//2+1, n//2+1),
                           np.arange(-n//2+1, n//2+1))
        kernel = np.exp(-(x**2+y**2)/(2*sigma**2))
        # this isn't really necessary, it preserves brightness
        kernel = kernel/np.sum(kernel) 
        laplacian = np.array([[0,1,0],
                              [1,-4,1],
                              [0,1,0]])
        # perform the convolution between the gaussian kernel
        # and the laplacian, in order to create the log kernel
        logkernel = my2dconv(kernel, laplacian)
        result = my2dconv(image, logkernel)
        return result
    print("Error: method has to be either \"gaussian\" or \"log\"")
